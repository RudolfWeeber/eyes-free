/*
 * Copyright (C) 2010 The IDEAL Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ideal.webaccess;

import java.io.FileNotFoundException;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.util.HashMap;

import android.content.ContentProvider;
import android.content.ContentValues;
import android.database.Cursor;
import android.net.Uri;
import android.os.ParcelFileDescriptor;
import android.speech.tts.TextToSpeech;
import android.speech.tts.TextToSpeech.OnInitListener;
import android.speech.tts.TextToSpeech.OnUtteranceCompletedListener;

/**
 * Content Provider for wrapping the TextToSpeech library. Usage:
 * content://com.ideal.webaccess.tts/MODE/RANDOMNUMBER/STRING_TO_BE_SPOKEN where
 * MODE is 0 for flush, 1 for queue, RANDOMNUMBER is a random number that is
 * used to force the content provider to speak the message (even if it was
 * previously spoken because it will have a different URI), and
 * STRING_TO_BE_SPOKEN is the actual string that should be spoken to the user.
 * What is served back is currently not used, but it should be possible to use
 * that to communicate back whether or not the TTS is currently speaking.
 */
public class TtsContentProvider extends ContentProvider {
    private static final String URI_PREFIX = "content://com.ideal.webaccess.tts";

    private TextToSpeech mTts;

    public static String constructUri(String url) {
        Uri uri = Uri.parse(url);
        return uri.isAbsolute() ? url : URI_PREFIX + url;
    }

    private String startupMessage = "";

    private int startupQueueMode = 0;
    
    public static boolean isSpeaking = false;
    
    private HashMap<String, String> speechParams;

    private OnInitListener mTtsInitListener = new OnInitListener() {
        @Override
        public void onInit(int status) {
            if (mTts == null) {
                mTts = new TextToSpeech(getContext(), mTtsInitListener);
                return;
            }
            speechParams = new HashMap<String, String>();
            speechParams.put(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID, "foo");
            mTts.setOnUtteranceCompletedListener(new OnUtteranceCompletedListener(){
                @Override
                public void onUtteranceCompleted(String utteranceId) {
                    isSpeaking = false;
                }                    
            });
            isSpeaking = true;
            mTts.speak(startupMessage, startupQueueMode, speechParams);
        }
    };

    @Override
    public ParcelFileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException {
        String text = "";
        int queueMode = 0;
        try {
            text = uri.toString();
            if (text.length() > URI_PREFIX.length()) {
                text = text.substring(URI_PREFIX.length() + 1);
                if (text.startsWith("1")) {
                    queueMode = 1;
                }
                // Throwaway the random number generated by the JS.
                // We are using the random number to force a content refresh.
                int stringStart = text.indexOf("/", 2) + 1;
                text = URLDecoder.decode(text.substring(stringStart), "UTF-8");
                text = StringUtils.unescapeHTML(text);
            }
        } catch (UnsupportedEncodingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        if (mTts == null) {
            startupMessage = text;
            startupQueueMode = queueMode;
            mTts = new TextToSpeech(getContext(), mTtsInitListener);
        } else {
            isSpeaking = true;
            mTts.speak(text, queueMode, speechParams);
        }
        return null;
    }

    @Override
    public boolean onCreate() {
        return true;
    }

    @Override
    public int delete(Uri uri, String s, String[] as) {
        throw new UnsupportedOperationException("Not supported by this provider");
    }

    @Override
    public String getType(Uri uri) {
        throw new UnsupportedOperationException("Not supported by this provider");
    }

    @Override
    public Uri insert(Uri uri, ContentValues contentvalues) {
        throw new UnsupportedOperationException("Not supported by this provider");
    }

    @Override
    public Cursor query(Uri uri, String[] as, String s, String[] as1, String s1) {
        throw new UnsupportedOperationException("Not supported by this provider");
    }

    @Override
    public int update(Uri uri, ContentValues contentvalues, String s, String[] as) {
        throw new UnsupportedOperationException("Not supported by this provider");
    }

}
